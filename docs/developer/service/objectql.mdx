---
title: ObjectQL 
---

# ObjectQL


"ObjectQL" is a query language designed for interacting with data objects within the Steedos Platform. Similar in concept to SQL used in relational databases, ObjectQL allows users to perform CRUD operations (Create, Read, Update, Delete) on structured data stored as objects.


The core capability of ObjectQL is its cross-database functionality. Using ObjectQL syntax, you can simultaneously accommodate both MongoDB and traditional SQL databases. This versatility allows for seamless integration and interaction with different database technologies, enabling developers to execute queries across various systems without changing the query language or worrying about the underlying database's specific nuances.

By abstracting the database layer, ObjectQL presents a unified query language that maintains consistent syntax and functionality, irrespective of whether the backend is a NoSQL system like MongoDB or a relational database management system (RDBMS) like MySQL, PostgreSQL, or others. This approach significantly simplifies data management tasks, making it easier for developers to work with data across multiple database systems and focus more on business logic rather than the intricacies of individual databases. It also aids in ensuring smoother scalability and adaptability of applications, as switching or integrating different database technologies can be achieved with minimal adjustments to the query code.

## this.getObject

You can use `this.getObject` to retrieve objects and perform ObjectQL queries.

:::tip
To use `this.getObject`, set `mixins: [require('@steedos/service-package-loader')]` in `package.service.js`.
:::

## CRUD

The ObjectQL microservice supports the following microservice actions that implement data manipulation (create, read, update, delete) and fire the corresponding triggers.

### find

Finds multiple records. This action triggers the configured trigger functions: beforeFind and afterFind.

- **Usage**： `broker.call('objectql.find', params, opt?)`
- **Arguments**：
  - actionName: String - The name of the action to be executed, in this case, the action is to find multiple records, thus the value should be 'objectql.find'.
  - params: 
    - objectName: String - The object name.
    - query: JSON - The query parameters [JSON], optional.
      - fields: Array - The selected fields to be returned, for example: ['field1', 'field2'].
      - filters: SteedosQueryFilters - An array of query filters.
      - sort: String - The sorting rule, for example: 'name desc'.
      - top: Number - The number of records to be returned.
      - skip: Number - The number of records to skip, typically used for pagination display.
  - opt: Optional.
    - meta:
       - user: SteedosUser - Current user information, which can be used to query the current user's permissions.
- **Returns**： An array of records. Returns an empty array [] if none are found.

```js
const res = await this.broker.call(
'objectql.find', 
{
  objectName: 'accounts',
  query: {
    fields: ['name', 'owner'],                      
    filters: ['owner', '=', ctx.meta.user.userId],  
    sort: 'name desc'                               
  },
},
{
  meta:{
    user: ctx.meta.user
  }
}
);

```


### findOne

The findOne function retrieves a single record. It triggers the configured trigger functions beforeFind and afterFindOne.

- **Usage**： `broker.call('objectql.findOne', params, opt?)`
- **Arguments**：
  - actionName: String - The name of the action to be executed, in this case, the action is to find a single record, thus the value should be 'objectql.findOne'.
  - params: 
    - objectName: String - The name of the object.
    - id: Number | String - The ID of the data you wish to query.
    - query: JSON - The query parameters [JSON]. Optional.
      - fields: Array - An array of field names. Optional. For example: ['field1', 'field2'].
  - opt: 
    - meta:
       - user: SteedosUser - Current user information, which can be used to query the current user's permissions.
- **Returns**： A single record [JSON].


```js
const res = await this.broker.call(
'objectql.findOne', 
{
  objectName: 'accounts',
  id: 'CChCmkiHrNeTM9jgA',     
  query: {
    fields: ['name', 'owner'],  
  }    
},
{
  meta:{
    user: ctx.meta.user
  }
}
);
```


### insert

This function inserts a single record. It triggers the configured trigger functions beforeInsert and afterInsert. After inserting special records like "tasks", notifications will be sent to designated personnel.

- **Usage：** `broker.call('objectql.insert', params, opt?)`
- **Arguments：**
  - actionName: String. The name of the action being executed, in this case it is 'objectql.insert'.
  - params: 
    - objectName: String. The name of the object.
    - doc: `Dictionary<any>` The data you wish to insert. It must include all required fields for the object.

  - opt: 
    - meta:
      - user: SteedosUser. Information about the current user, which can be used to check the user's permissions. Optional.
- **Returns：** The data that was successfully inserted.

```js

const res = await this.broker.call(
'objectql.insert', 
{
  objectName: 'accounts', 
  doc: {
    name: 'Here is the name of the inserted data.'
  }
},
{
  meta:{
    user: ctx.me ta.user
  }
}
);

```

The name field is a required field for the accounts object, and there may be differences between objects. Below is a table containing individual fields for this object (including required fields and system fields).
  
|Basic Properties  |Required or Not      |Description   |
| ----        | ----        | ---- |
| name 	      | &#x2714;    | Required when adding a record to accounts object. There may be differences in required fields among different objects. |
| id 	        | &#x2716;    | If not provided, the system will automatically maintain it. |
| space 	    | &#x2716;    | 	Automatically maintained by the system. |
| owner 	    | &#x2716;    | 	Automatically maintained by the system. |
| created_by  | &#x2716;    | 	Automatically maintained by the system. |
| modified_by | &#x2716;    | 	Automatically maintained by the system. |
| created	    | &#x2716;    | 	Automatically maintained by the system. |
| modified	  | &#x2716;    | 	Automatically maintained by the system. |


### delete

This function is used to delete a single record. The beforeDelete and afterDelete trigger functions configured for this operation will be triggered.

- **Usage**： `broker.call('objectql.delete', params, opt?)`
- **Arguments**：
  - actionName: String The name of the action. In this case, the action is to delete a record, so the value should be 'objectql.delete'.
  - params: 
    - id: number | string The ID of the data you want to change.
    - objectName: String The name of the object.
  - opt: 
    - meta:
       - user: SteedosUser Information about the current user, which can be used to check the user's permissions. Optional.
- **Returns**：
  - Success: 1.
  - Failure: An error message is thrown.

```js
const res = await this.broker.call(
'objectql.delete', 
{
  objectName: 'accounts',
  id: "Xgf3NxXJWAXJff9FQ" 
},
{
  meta:{
    user: ctx.meta.user
  }
}
);
```


### update

This function is used to update a single record. The beforeUpdate and afterUpdate trigger functions configured for this operation will be triggered. After updating specific records, such as "tasks", notifications will be sent to designated personnel.

- **Usage**： `broker.call('objectql.update', params, opt?)`
- **Arguments**：
  - actionName: String The name of the action. In this case, the action is to update a record, so the value should be 'objectql.update'.
  - params: 
    - id: number | string The ID of the data you want to change.
    - objectName: String The name of the object.
    - doc:`Dictionary<any>` The data you want to update.
  - opt: 
    - meta:
       - user: SteedosUser Information about the current user, which can be used to check the user's permissions. Optional.
- **Returns**： The data after a successful update.

```js
const res = await this.broker.call(
'objectql.update', 
{
  objectName: 'accounts',
  doc: {
    name: 'The name of the data after it has been updated.'
  },
  id: "CChCmkiHrNeTM9jgA"
},
{
  meta:{
    user: ctx.meta.user
  }
}
);

```


### aggregate

Find aggregated records. This action triggers the configured trigger functions: beforeAggregate and afterAggregate.

Aggregation: Aggregation operations process data records and return calculated results. Aggregation operations combine values from multiple documents, and various operations can be performed on grouped data to return single results.

- **Usage**： `broker.call('objectql.aggregate', params, opt?)`
- **Arguments**：
  - actionName: String The name of the action, which is used to perform the aggregation operation. Its value is 'objectql.aggregate'.
  - params: 
    - objectName: String The object name.
    - query: The parameters related to querying the data in JSON format.
      - filters: Array An optional array of query conditions.
    - externalPipeline: An array of MongoDB aggregation pipelines.See [MongoDB Aggregation Documentation](https://www.mongodb.com/docs/manual/reference/aggregation/)。
  - opt: 
    - meta:
       - user: SteedosUser The current user information, which can be used to check the permission of the current user. Optional.
- **Returns**: An array of aggregated records.


```js
const res = await this.broker.call(
'objectql.aggregate', 
{
  objectName: 'accounts',
  query: {
    filters: ['owner', '=', ctx.meta.user.userId],  
  },
  externalPipeline: [{ $count: 'users_count'}]      
},
{
  meta:{
    user: ctx.meta.user
  }
}
);
```




## Direct CRUD

ObjectQL microservices support microservice actions with the direct prefix, which implements CRUD operations on data. These actions will not trigger corresponding triggers.

## Filter Criteria


Steedos uses an array format to define one or more filter criteria. For example, the following filter is used to query data that was created this month and assigned to the current user.

```javascript
filters: [["priority", "=", "high"],["owner","=","{userId}"],["created", "=", this_month]]
filters: [["status", "=", ["closed","open"]]]
filters: [["age", "between", [20,30]]]
```

### Operations

* "=": equals
* "!=":  not equals
* ">": greater than
* ">=": greater than or equal to
* "<": less than
* "<=": less than or equal to
* "startswith": starts with...
* "contains": contains...
* "notcontains": does not contain...
* "between": within a range, only supports numerical and datetime types

### Combined Filters

Multiple filters can be combined using "and" and "or" operations. For example:

* \[ \[ "value", ">", 3 \], "and", \[ "value", "<", 7 \] \]
* \[ \[ "value", ">", 7 \], "or", \[ "value", "<", 3 \] \]

If no "and" or "or" operation is specified, the system will default to executing filters using the "and" operation. Therefore, the following two writing formats will yield the same result.

* \[ \[ "value", ">", 3 \], "and", \[ "value", "<", 7 \] \]
* \[ \[ "value", ">", 3 \], \[ "value", "<", 7 \] \]

### Array Value Support

When the operator is "=", the condition will automatically be split into multiple filtering conditions using the "or" operator, similar to implementing the "in" operation function. Therefore, the following two writing formats will yield the same result.

* \[\["status", "in", \["closed","open"\]\]\]
* \[ \[ "status", "=", "closed" \], "or", \[ "status", "=", "open" \] \]

When the operator is "!=", the condition will automatically be split into multiple filtering conditions using the "and" operator, so the following two writing formats will yield the same results:

* \[\["status", "not in", \["closed","open"\]\]\]
* \[ \[ "status", "!=", "closed" \], "and", \[ "status", "!=", "open" \] \]

When the operator is "between", the condition will automatically be transformed into filtering conditions corresponding to the ">=" and "<=" operators. Therefore, the following sets of conditions will yield the same results:

* \[\["age", "between", \[20,30\]\]\] equivalent to \[ \[ "age", ">=", 20 \], "and", \[ "age", "<=", 30 \] \]
* \[\["age", "between", \[null,30\]\]\] equivalent to \[ \[ "age", "<=", 30 \] \]
* \[\["age", "between", \[20,null\]\]\] equivalent to \[ \[ "age", ">=", 20 \] \]



### Query Datetime Fields

For fields of date and time types, the database saves them in UTC time. For date type fields, the time saved is 00:00:00.

When querying date and time type fields, you need to convert the time to UTC format before executing the query.

For example, if you want to search for documents with a creation date before 1:00 PM Beijing time, you need to convert Beijing time to GMT time before executing the query.

```javascript
[["created","<=","2019-08-06T07:00:00Z"]]
```


